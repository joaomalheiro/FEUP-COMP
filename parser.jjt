options {
    MULTI=true;
    LOOKAHEAD=1;
}

PARSER_BEGIN(JmmParser)
// código Java que invoca o parser
public class JmmParser {
    public static void main(String args[]) throws ParseException {
        // criação do objecto utilizando o constructor com argumento para
        // ler do standard input (teclado)
        try {
            java.io.FileInputStream file = new java.io.FileInputStream("Test.jmm");
            JmmParser parser = new JmmParser(file);
            SimpleNode root = parser.program();
            root.dump("");
        } catch (java.io.FileNotFoundException e) {
            System.out.println(e);
        }
    }
}
PARSER_END(JmmParser)
// símbolos que não devem ser considerados na análise
SKIP :
{
    " " | "\t" | "\r" | "\n"
}
// definição dos tokens (símbolos terminais)
TOKEN :
{
    < INTEGER : (["0" - "9"])+ >
    | < CLASS : "class" >
    | < EXTENDS : "extends" >
    | < LEFTBRACKET : "{" >
    | < RIGHTBRACKET : "}" >
    | < LEFTPARENTHESES : "(" >
    | < RIGHTPARENTHESES : ")" >
    | < LEFTSQUAREBRACKET : "[" >
    | < RIGHTSQUAREBRACKET : "]" >
    | < INT : "int" >
    | < BOOLEAN : "boolean" >
    | < STRINGARRAY : "String[]" >
    | < VOID : "void" >
    | < COLON : "," >
    | < DOT : "." >
    | < SEMICOLON : ";" >
    | < PUBLIC : "public" >
    | < STATIC : "static" >
    | < MAIN : "main" >
    | < IF : "if" >    
    | < ELSE : "else" >      
    | < WHILE : "while" >  
    | < RETURN: "return" >
    | < EQUALS: "=" >    
    | < COMMERCIALE: "&&" >
    | < MINOR: "<" >
    | < PLUS: "+" >
    | < MINUS: "-" >
    | < ASTERISC: "*" >
    | < SLASH: "/" >
    | < LENGTH: "length" >
    | < TRUE: "true" >
    | < FALSE: "false" >
    | < THIS: "this" >
    | < NEW: "new" >
    | < EXCLAMATION: "!" >
    | < IDENTIFIER : (["a" - "z"] | ["A" - "Z"])+ (["a" - "z"] | ["A" - "Z"] | ["0" - "9"])* >
}
// definição da produção
SimpleNode program() : {}
{
    classDeclaration() <EOF> {return jjtThis;}
}

void classDeclaration() : {Token t;}
{
    <CLASS> t=<IDENTIFIER> {jjtThis.name = t.image;}#IDENTIFIER [<EXTENDS> (t=<IDENTIFIER> {jjtThis.name = t.image;}#IDENTIFIER) #EXTENDS]
    <LEFTBRACKET> 
        (varDeclaration())*
        (<PUBLIC> (mainDeclaration() | methodDeclaration()) #PUBLIC)*
    <RIGHTBRACKET>
}

void mainDeclaration() : {Token t;} 
{
    <STATIC> #STATIC <VOID> #VOID <MAIN> <LEFTPARENTHESES> <STRINGARRAY> #STRINGARRAY t=<IDENTIFIER> {jjtThis.name = t.image;}#IDENTIFIER <RIGHTPARENTHESES>
    <LEFTBRACKET>
        methodBody()
    <RIGHTBRACKET>
}

void varDeclaration() : {Token t;}
{
    type() t=<IDENTIFIER> {jjtThis.name = t.image;}#IDENTIFIER <SEMICOLON>
}

void methodDeclaration() : {Token t;}
{
    type() t=<IDENTIFIER> {jjtThis.name = t.image;}#IDENTIFIER <LEFTPARENTHESES> (parameterDeclaration() ( <COLON> parameterDeclaration())*)? <RIGHTPARENTHESES>
    <LEFTBRACKET>
        methodBody()
        <RETURN> expression() #RETURN <SEMICOLON>
    <RIGHTBRACKET>
}

void methodBody() : {}
{
    (LOOKAHEAD(2) varDeclaration())*
    (statement())*
}

void parameterDeclaration() : {Token t;}
{
    type() t=<IDENTIFIER> {jjtThis.name = t.image;}#IDENTIFIER
}

void type() #void: {Token t;}                                    
{
    (<INT> #INT [<LEFTSQUAREBRACKET> #LEFTSQUAREBRACKET <RIGHTSQUAREBRACKET> #RIGHTSQUAREBRACKET]) | 
    (<BOOLEAN> #BOOLEAN) | 
    (t=<IDENTIFIER> {jjtThis.name = t.image;}#IDENTIFIER)
}

void statement() #void: {Token t;}                               
{
    (<LEFTBRACKET> (statement())* <RIGHTBRACKET>) |   
    (<IF> condition() body() #IF(2) <ELSE> statement() #ELSE) |
    (whileStatement()) |
    (expression() <SEMICOLON>)
}

void whileStatement() #void: {}
{
    <WHILE>
    try {
        condition()
    }
    catch (ParseException e) {
        System.out.println(e.toString());
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != RIGHTPARENTHESES);
    }
    body()
    #WHILE(2)
}

void condition() : {}
{
    <LEFTPARENTHESES> expression() <RIGHTPARENTHESES>
}

void body() : {}
{
    statement()
}

void expression() #void: {}
{
    expression2() [<EQUALS> expression2() #EQUALS(2)]
}

void expression2() #void: {}
{
    expression3() (
        <COMMERCIALE> expression3() #COMMERCIALE(2)
    )*
}

void expression3() #void: {}
{
    expression4() (
        <MINOR> expression4() #MINOR(2)
    )*
}

void expression4() #void: {}                        
{
    expression5() (
        (<PLUS> expression5() #PLUS(2)) | 
        (<MINUS> expression5() #MINUS(2))
    )*
}

void expression5() #void: {}                        
{
    expression6() (
        (<ASTERISC> expression6() #ASTERISC(2)) | 
        (<SLASH> expression6() #SLASH(2))
    )*
}

void expression6() #void: {}                        
{
    expression7() (
        array() #array(2)
    )*
}

void expression7() #void: {}                             
{
    expressionfinal() (
        <DOT> (
            (<LENGTH> #LENGTH) | 
            (functionCall()) 
        ) 
        #DOT(2)
    )*
}

void functionCall() : {Token t;}
{
    t=<IDENTIFIER> {jjtThis.name = t.image;}#IDENTIFIER <LEFTPARENTHESES> (parameters())? <RIGHTPARENTHESES>
}

void parameters() : {}
{
    expression() (<COLON> expression())*
}

void expressionfinal() #void: {Token t;}                                            
{
    (t=<INTEGER> {jjtThis.name = t.image;}#INTEGER)|
    (<TRUE> #TRUE) |
    (<FALSE> #FALSE) |
    (t=<IDENTIFIER> {jjtThis.name = t.image;}#IDENTIFIER) |
    (<THIS> #THIS) |
    (<EXCLAMATION> expressionfinal() #EXCLAMATION) |
    (<LEFTPARENTHESES> expression() <RIGHTPARENTHESES>) |
    (<NEW> ((<INT> #INT array() #NEW(2)) | ((t=<IDENTIFIER> {jjtThis.name = t.image;}#IDENTIFIER) #NEW <LEFTPARENTHESES> <RIGHTPARENTHESES>) ))
}

void array() #void: {}
{
    <LEFTSQUAREBRACKET> expression() <RIGHTSQUAREBRACKET>
}