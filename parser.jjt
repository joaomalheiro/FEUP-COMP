options {
    MULTI=true;
    LOOKAHEAD=1;
}

PARSER_BEGIN(JmmParser)
// código Java que invoca o parser
import java.util.ArrayList;
public class JmmParser {
    static ArrayList<SymbolTable> symbolTables = new ArrayList<SymbolTable>();

    public static void main(String args[]) throws ParseException {
        // criação do objecto utilizando o constructor com argumento para
        // ler do standard input (teclado)
        try {
            java.io.FileInputStream file = new java.io.FileInputStream("test-files/" + args[0]);
            JmmParser parser = new JmmParser(file);
            SimpleNode root = parser.program();
            root.dump("");
        } catch (java.io.FileNotFoundException e) {
            System.out.println(e);
        }
        for (SymbolTable s : symbolTables) {
            System.out.println(s.toString());
        }
    }
}
PARSER_END(JmmParser)
// símbolos que não devem ser considerados na análise
SKIP :
{
    " " 
    | "\t" 
    | "\r" 
    | "\n"
    | < "//"(~["\r","\n"])* >
    | < "/*" > : MLCOMMENT
}
//SKIP multi-lined comments
<MLCOMMENT> SKIP :
{
  < "*/" > : DEFAULT
| < ~[] >   
}
//global variable for error count
TOKEN_MGR_DECLS : {
    int errors = 0;
}
// definição dos tokens (símbolos terminais)
TOKEN :
{
    < INTEGER : (["0" - "9"])+ >
    | < CLASS : "class" >
    | < EXTENDS : "extends" >
    | < LEFTBRACKET : "{" >
    | < RIGHTBRACKET : "}" >
    | < LEFTPARENTHESES : "(" >
    | < RIGHTPARENTHESES : ")" >
    | < LEFTSQUAREBRACKET : "[" >
    | < RIGHTSQUAREBRACKET : "]" >
    | < INT : "int" >
    | < BOOLEAN : "boolean" >
    | < STRINGARRAY : "String[]" >
    | < VOID : "void" >
    | < COLON : "," >
    | < DOT : "." >
    | < SEMICOLON : ";" >
    | < PUBLIC : "public" >
    | < STATIC : "static" >
    | < MAIN : "main" >
    | < IF : "if" >    
    | < ELSE : "else" >      
    | < WHILE : "while" >  
    | < RETURN: "return" >
    | < EQUALS: "=" >    
    | < COMMERCIALE: "&&" >
    | < MINOR: "<" >
    | < ADDSUB: "+" | "-" >
    | < MULDIV: "*" | "/" >
    | < LENGTH: "length" >
    | < TRUE: "true" >
    | < FALSE: "false" >
    | < THIS: "this" >
    | < NEW: "new" >
    | < EXCLAMATION: "!" >
    | < IDENTIFIER : (["a" - "z"] | ["A" - "Z"])+ (["a" - "z"] | ["A" - "Z"] | ["0" - "9"] | "_")* >
}
// definição da produção
SimpleNode program() : {}
{
    classDeclaration() <EOF> {return jjtThis;}
}

void classDeclaration() : {Token t, t1; SymbolTable classTable;}
{
    {classTable = new SymbolTable();}
    {symbolTables.add(classTable);}
    <CLASS> t=<IDENTIFIER> {jjtThis.name = t.image;}#IDENTIFIER [t1=<EXTENDS> (t=<IDENTIFIER> {jjtThis.name = t.image;}#IDENTIFIER) {jjtThis.index = t1.kind;}#EXTENDS(1)]
    <LEFTBRACKET> 
        (varDeclaration(classTable, Symbol.Access.global))*
        (t=<PUBLIC> (mainDeclaration(classTable) | methodDeclaration(classTable)) {jjtThis.index = t.kind;}#PUBLIC(1))*
    <RIGHTBRACKET>
}

void mainDeclaration(SymbolTable classTable) : {Token t; Symbol mainMethod, mainParam; SymbolTable mainTable;} 
{
    {mainMethod = new Symbol("void", "main", Symbol.Access.global, true); mainParam = new Symbol("String[]", Symbol.Access.parameter, false);}
    {mainTable = new SymbolTable(classTable);}
    {symbolTables.add(mainTable);}
    t=<STATIC> {jjtThis.index = t.kind;}#STATIC t=<VOID> {jjtThis.index = t.kind;}#VOID <MAIN> <LEFTPARENTHESES> t=<STRINGARRAY> {jjtThis.index = t.kind;}#STRINGARRAY t=<IDENTIFIER> {jjtThis.name = t.image; mainParam.setIdentifier(t.image);}#IDENTIFIER(1) <RIGHTPARENTHESES>
    <LEFTBRACKET>
        methodBody(mainTable)
    <RIGHTBRACKET>
    {mainTable.addSymbol(mainParam);}
    {classTable.addSymbol(mainMethod);}
}

void varDeclaration(SymbolTable table, Symbol.Access access) : {Token t; Symbol var;}
{
    {var = new Symbol(access, false);}
    type(var) t=<IDENTIFIER> {jjtThis.name = t.image; var.setIdentifier(t.image);}#IDENTIFIER <SEMICOLON>
    {table.addSymbol(var);} 
}

void methodDeclaration(SymbolTable classTable) : {Token t; Symbol method; SymbolTable methodTable;}
{
    {method = new Symbol(Symbol.Access.global, true);}
    {methodTable = new SymbolTable(classTable);}
    {symbolTables.add(methodTable);}
    type(method) t=<IDENTIFIER> {jjtThis.name = t.image; method.setIdentifier(t.image);}#IDENTIFIER <LEFTPARENTHESES> (parameterDeclaration(methodTable) ( <COLON> parameterDeclaration(methodTable))*)? <RIGHTPARENTHESES>
    <LEFTBRACKET>
        methodBody(methodTable)
        t=<RETURN> expression(methodTable) {jjtThis.index = t.kind;}#RETURN(1) <SEMICOLON>
    <RIGHTBRACKET>
    {classTable.addSymbol(method);}
}

void methodBody(SymbolTable methodTable) : {}
{
    (LOOKAHEAD(2) varDeclaration(methodTable, Symbol.Access.local))*
    (statement(methodTable))*
}

void parameterDeclaration(SymbolTable methodTable) : {Token t; Symbol param;}
{
    {param = new Symbol(Symbol.Access.parameter, false);}
    type(param) t=<IDENTIFIER> {jjtThis.name = t.image; param.setIdentifier(t.image);}#IDENTIFIER
    {methodTable.addSymbol(param);}
}

void type(Symbol symbol) #void : {Token t;}
{
    (t=<INT> {jjtThis.index = t.kind;}#INT {symbol.setType("int");} [t=<LEFTSQUAREBRACKET> {jjtThis.index = t.kind;}#LEFTSQUAREBRACKET t=<RIGHTSQUAREBRACKET> {jjtThis.index = t.kind;}#RIGHTSQUAREBRACKET {symbol.setType("int[]");}]) | 
    (t=<BOOLEAN> {jjtThis.index = t.kind;}#BOOLEAN {symbol.setType("boolean");}) | 
    (t=<IDENTIFIER> {jjtThis.name = t.image;}#IDENTIFIER {symbol.setType(t.image);})
}

void statement(SymbolTable scopeTable) #void : {Token t;}
{
    (<LEFTBRACKET> (statement(scopeTable))* <RIGHTBRACKET>)
    | ifStatement(scopeTable)
    | whileStatement(scopeTable)
    | (expression(scopeTable) <SEMICOLON>)
}

void ifStatement(SymbolTable ifTable) #void : {Token t;}
{
    t=<IF> condition(ifTable) 
    body(ifTable) {jjtThis.index = t.kind;}#IF(2) 
    t=<ELSE> 
    body(ifTable) {jjtThis.index = t.kind;}#ELSE(1)
}

void whileStatement(SymbolTable whileTable) #void: {Token t, t1;}
{
    t=<WHILE>
    try {
        condition(whileTable)
    }
    catch (ParseException e) {
        System.out.println(e.toString());
        {token_source.errors++; if(token_source.errors==10){System.out.println("10 errors found, stopping program!"); System.exit(-1);}}
        do {
            t1 = getNextToken();
        } while (t1.kind != RIGHTPARENTHESES);
    }
    body(whileTable)
    {jjtThis.index = t.kind;}#WHILE(2)
}

void condition(SymbolTable scopeTable) : {}
{
    <LEFTPARENTHESES> expression(scopeTable) <RIGHTPARENTHESES>
}

void body(SymbolTable scopeTable) : {}
{
    statement(scopeTable)
}

void expression(SymbolTable scopeTable) #void: {Token t;}
{
    expression2(scopeTable) [t=<EQUALS> expression2(scopeTable) {jjtThis.index = t.kind;}#EQUALS(2)]
}

void expression2(SymbolTable scopeTable) #void: {Token t;}
{
    expression3(scopeTable) (
        t=<COMMERCIALE> expression3(scopeTable) {jjtThis.index = t.kind;}#COMMERCIALE(2)
    )*
}

void expression3(SymbolTable scopeTable) #void: {Token t;}
{
    expression4(scopeTable) (
        t=<MINOR> expression4(scopeTable) {jjtThis.index = t.kind;}#MINOR(2)
    )*
}

void expression4(SymbolTable scopeTable) #void: {Token t;}                        
{
    expression5(scopeTable) (
        t=<ADDSUB> expression5(scopeTable) {jjtThis.name = t.image;}#ADDSUB(2)
    )*
}

void expression5(SymbolTable scopeTable) #void: {Token t;}                        
{
    expression6(scopeTable) (
        t=<MULDIV> expression6(scopeTable) {jjtThis.name = t.image;}#MULDIV(2)
    )*
}

void expression6(SymbolTable scopeTable) #void: {}                        
{
    expression7(scopeTable) (
        array(scopeTable) #array(2)
    )*
}

void expression7(SymbolTable scopeTable) #void: {Token t;}                             
{
    expressionfinal(scopeTable) (
        t=<DOT> (
            (t=<LENGTH> {jjtThis.index = t.kind;}#LENGTH) | 
            (functionCall(scopeTable)) 
        ) 
        {jjtThis.index = t.kind;}#DOT(2)
    )*
}

void functionCall(SymbolTable scopeTable) : {Token t;}
{
    t=<IDENTIFIER> {jjtThis.name = t.image;}#IDENTIFIER <LEFTPARENTHESES> (parameters(scopeTable))? <RIGHTPARENTHESES>
}

void parameters(SymbolTable scopeTable) : {}
{
    expression(scopeTable) (<COLON> expression(scopeTable))*
}

void expressionfinal(SymbolTable scopeTable) #void: {Token t, t1;}                                            
{
    (t=<INTEGER> {jjtThis.name = t.image;}#INTEGER)|
    (t=<TRUE> {jjtThis.index = t.kind;}#TRUE) |
    (t=<FALSE> {jjtThis.index = t.kind;}#FALSE) |
    (t=<IDENTIFIER> {jjtThis.name = t.image;}#IDENTIFIER) |
    (t=<THIS> {jjtThis.index = t.kind;}#THIS) |
    (t=<EXCLAMATION> expressionfinal(scopeTable) {jjtThis.index = t.kind;}#EXCLAMATION) |
    (<LEFTPARENTHESES> expression(scopeTable) <RIGHTPARENTHESES>) |
    (t1=<NEW> (((t=<INT> {jjtThis.index = t.kind;}#INT) array(scopeTable) #array(2) {jjtThis.index = t1.kind;}#NEW(1)) | ((t=<IDENTIFIER> {jjtThis.name = t.image;}#IDENTIFIER) {jjtThis.index = t1.kind;}#NEW(1) <LEFTPARENTHESES> <RIGHTPARENTHESES>) ))
}

void array(SymbolTable scopeTable) #void: {}
{
    <LEFTSQUAREBRACKET> expression(scopeTable) <RIGHTSQUAREBRACKET>
}